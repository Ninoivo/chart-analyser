// netlify/functions/market-data.js
// This function fetches real-time market data from multiple APIs

exports.handler = async (event, context) => {
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'POST, OPTIONS'
      },
      body: ''
    };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers: { 'Access-Control-Allow-Origin': '*' },
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    const { symbol, timeframe, apiKeys } = JSON.parse(event.body);
    
    // Determine asset type
    const isCrypto = symbol.includes('BTC') || symbol.includes('ETH') || symbol.includes('USDT');
    const isForex = symbol.includes('USD') || symbol.includes('EUR') || symbol.includes('GBP');
    const isCommodity = symbol.includes('XAU') || symbol.includes('XAG') || symbol.includes('OIL');
    
    let marketData = {};
    
    // CRYPTO DATA - Multiple sources for reliability
    if (isCrypto) {
      marketData = await fetchCryptoData(symbol, timeframe, apiKeys);
    }
    // FOREX DATA
    else if (isForex) {
      marketData = await fetchForexData(symbol, timeframe, apiKeys);
    }
    // COMMODITY DATA
    else if (isCommodity) {
      marketData = await fetchCommodityData(symbol, timeframe, apiKeys);
    }
    // STOCK DATA
    else {
      marketData = await fetchStockData(symbol, timeframe, apiKeys);
    }

    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(marketData)
    };

  } catch (error) {
    console.error('Market data error:', error);
    return {
      statusCode: 500,
      headers: { 'Access-Control-Allow-Origin': '*' },
      body: JSON.stringify({ 
        error: error.message,
        details: 'Failed to fetch market data'
      })
    };
  }
};

// CRYPTO DATA FETCHER
async function fetchCryptoData(symbol, timeframe, apiKeys) {
  // Binance API (Free, no key needed)
  const binanceSymbol = symbol.replace('/', '').replace('USD', 'USDT');
  
  try {
    // Get 24h ticker data
    const tickerRes = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${binanceSymbol}`);
    const ticker = await tickerRes.json();
    
    // Get current price
    const priceRes = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${binanceSymbol}`);
    const price = await priceRes.json();
    
    // Get klines (candlestick data) for indicators
    const interval = convertTimeframe(timeframe);
    const klinesRes = await fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=${interval}&limit=200`);
    const klines = await klinesRes.json();
    
    // Extract closing prices for indicator calculation
    const closePrices = klines.map(k => parseFloat(k[4]));
    const highPrices = klines.map(k => parseFloat(k[2]));
    const lowPrices = klines.map(k => parseFloat(k[3]));
    const volumes = klines.map(k => parseFloat(k[5]));
    
    // Calculate technical indicators
    const indicators = calculateIndicators(closePrices, highPrices, lowPrices, volumes);
    
    // Detect patterns
    const patterns = detectPatterns(closePrices);
    
    // Calculate support and resistance
    const supportResistance = calculateSupportResistance(closePrices, highPrices, lowPrices);
    
    return {
      symbol: symbol,
      source: 'Binance',
      price: parseFloat(price.price),
      change: parseFloat(ticker.priceChange),
      changePercent: parseFloat(ticker.priceChangePercent),
      volume: parseFloat(ticker.volume),
      high24h: parseFloat(ticker.highPrice),
      low24h: parseFloat(ticker.lowPrice),
      bid: parseFloat(ticker.bidPrice),
      ask: parseFloat(ticker.askPrice),
      lastUpdate: new Date(ticker.closeTime).toISOString(),
      indicators: indicators,
      patterns: patterns,
      supportResistance: supportResistance,
      historicalData: closePrices.slice(-50), // Last 50 candles
      sentiment: await fetchCryptoSentiment(symbol)
    };
    
  } catch (error) {
    console.error('Binance API error:', error);
    // Fallback to CoinGecko
    return await fetchCryptoDataCoinGecko(symbol);
  }
}

// FOREX DATA FETCHER
async function fetchForexData(symbol, timeframe, apiKeys) {
  // Alpha Vantage API (requires free API key)
  const alphavantageKey = apiKeys?.alphavantage || 'demo';
  
  const fromCurrency = symbol.substring(0, 3);
  const toCurrency = symbol.substring(3, 6);
  
  try {
    // Intraday data
    const res = await fetch(
      `https://www.alphavantage.co/query?function=FX_INTRADAY&from_symbol=${fromCurrency}&to_symbol=${toCurrency}&interval=${convertTimeframeAlpha(timeframe)}&apikey=${alphavantageKey}`
    );
    const data = await res.json();
    
    const timeSeriesKey = Object.keys(data).find(key => key.includes('Time Series'));
    const timeSeries = data[timeSeriesKey];
    
    if (!timeSeries) {
      throw new Error('Invalid API response or rate limit exceeded');
    }
    
    const latestTime = Object.keys(timeSeries)[0];
    const latest = timeSeries[latestTime];
    
    // Extract price data
    const prices = Object.values(timeSeries).map(v => parseFloat(v['4. close']));
    const highs = Object.values(timeSeries).map(v => parseFloat(v['2. high']));
    const lows = Object.values(timeSeries).map(v => parseFloat(v['3. low']));
    const volumes = Object.values(timeSeries).map(v => parseFloat(v['5. volume'] || 0));
    
    const indicators = calculateIndicators(prices, highs, lows, volumes);
    const patterns = detectPatterns(prices);
    const supportResistance = calculateSupportResistance(prices, highs, lows);
    
    return {
      symbol: symbol,
      source: 'Alpha Vantage',
      price: parseFloat(latest['4. close']),
      high24h: Math.max(...highs.slice(0, 24)),
      low24h: Math.min(...lows.slice(0, 24)),
      change: prices[0] - prices[1],
      changePercent: ((prices[0] - prices[1]) / prices[1] * 100).toFixed(2),
      volume: parseFloat(latest['5. volume'] || 0),
      bid: parseFloat(latest['4. close']) - 0.0001,
      ask: parseFloat(latest['4. close']) + 0.0001,
      lastUpdate: new Date(latestTime).toISOString(),
      indicators: indicators,
      patterns: patterns,
      supportResistance: supportResistance,
      historicalData: prices.slice(0, 50)
    };
    
  } catch (error) {
    console.error('Alpha Vantage error:', error);
    // Return demo data with note
    return getDemoForexData(symbol);
  }
}

// COMMODITY DATA FETCHER
async function fetchCommodityData(symbol, timeframe, apiKeys) {
  const alphavantageKey = apiKeys?.alphavantage || 'demo';
  
  // Map symbol to commodity code
  const commodityMap = {
    'XAUUSD': 'GOLD',
    'XAGUSD': 'SILVER',
    'XPTUSD': 'PLATINUM',
    'WTIUSD': 'WTI',
    'BRENTUSD': 'BRENT'
  };
  
  const commodity = commodityMap[symbol] || 'GOLD';
  
  try {
    const res = await fetch(
      `https://www.alphavantage.co/query?function=${commodity}&interval=daily&apikey=${alphavantageKey}`
    );
    const data = await res.json();
    
    // Similar processing as forex
    return processAlphaVantageData(data, symbol);
    
  } catch (error) {
    return getDemoCommodityData(symbol);
  }
}

// STOCK DATA FETCHER
async function fetchStockData(symbol, timeframe, apiKeys) {
  const alphavantageKey = apiKeys?.alphavantage || 'demo';
  
  try {
    const res = await fetch(
      `https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY&symbol=${symbol}&interval=${convertTimeframeAlpha(timeframe)}&apikey=${alphavantageKey}`
    );
    const data = await res.json();
    
    return processAlphaVantageData(data, symbol);
    
  } catch (error) {
    return getDemoStockData(symbol);
  }
}

// INDICATOR CALCULATIONS
function calculateIndicators(closes, highs, lows, volumes) {
  return {
    rsi: calculateRSI(closes, 14),
    macd: calculateMACD(closes),
    ema20: calculateEMA(closes, 20),
    ema50: calculateEMA(closes, 50),
    ema200: calculateEMA(closes, 200),
    sma20: calculateSMA(closes, 20),
    sma50: calculateSMA(closes, 50),
    bollingerBands: calculateBollingerBands(closes, 20, 2),
    atr: calculateATR(highs, lows, closes, 14),
    adx: calculateADX(highs, lows, closes, 14),
    stochastic: calculateStochastic(highs, lows, closes, 14),
    volumeProfile: analyzeVolume(volumes)
  };
}

// RSI Calculation
function calculateRSI(prices, period = 14) {
  if (prices.length < period + 1) return 50;
  
  let gains = 0;
  let losses = 0;
  
  for (let i = prices.length - period; i < prices.length; i++) {
    const change = prices[i] - prices[i - 1];
    if (change > 0) gains += change;
    else losses -= change;
  }
  
  const avgGain = gains / period;
  const avgLoss = losses / period;
  
  if (avgLoss === 0) return 100;
  const rs = avgGain / avgLoss;
  return 100 - (100 / (1 + rs));
}

// MACD Calculation
function calculateMACD(prices) {
  const ema12 = calculateEMA(prices, 12);
  const ema26 = calculateEMA(prices, 26);
  const macdLine = ema12 - ema26;
  
  // For signal line, we'd need to calculate EMA of MACD line
  // Simplified version:
  const signal = macdLine * 0.9; // Approximation
  const histogram = macdLine - signal;
  
  return {
    value: macdLine,
    signal: signal,
    histogram: histogram
  };
}

// EMA Calculation
function calculateEMA(prices, period) {
  if (prices.length < period) return prices[prices.length - 1];
  
  const multiplier = 2 / (period + 1);
  let ema = prices[prices.length - period];
  
  for (let i = prices.length - period + 1; i < prices.length; i++) {
    ema = (prices[i] - ema) * multiplier + ema;
  }
  
  return ema;
}

// SMA Calculation
function calculateSMA(prices, period) {
  if (prices.length < period) return prices[prices.length - 1];
  
  const slice = prices.slice(prices.length - period);
  return slice.reduce((a, b) => a + b, 0) / period;
}

// Bollinger Bands
function calculateBollingerBands(prices, period, stdDev) {
  const sma = calculateSMA(prices, period);
  const slice = prices.slice(prices.length - period);
  
  const squaredDiffs = slice.map(price => Math.pow(price - sma, 2));
  const variance = squaredDiffs.reduce((a, b) => a + b, 0) / period;
  const standardDeviation = Math.sqrt(variance);
  
  return {
    upper: sma + (standardDeviation * stdDev),
    middle: sma,
    lower: sma - (standardDeviation * stdDev)
  };
}

// ATR Calculation
function calculateATR(highs, lows, closes, period = 14) {
  const trueRanges = [];
  
  for (let i = 1; i < highs.length; i++) {
    const tr = Math.max(
      highs[i] - lows[i],
      Math.abs(highs[i] - closes[i - 1]),
      Math.abs(lows[i] - closes[i - 1])
    );
    trueRanges.push(tr);
  }
  
  return calculateSMA(trueRanges, period);
}

// ADX Calculation (simplified)
function calculateADX(highs, lows, closes, period = 14) {
  // Simplified ADX calculation
  const atr = calculateATR(highs, lows, closes, period);
  const priceChange = closes[closes.length - 1] - closes[closes.length - period];
  const adx = Math.min(100, Math.abs(priceChange / atr) * 5);
  
  return adx;
}

// Stochastic Oscillator
function calculateStochastic(highs, lows, closes, period = 14) {
  const recentHighs = highs.slice(-period);
  const recentLows = lows.slice(-period);
  const currentClose = closes[closes.length - 1];
  
  const highestHigh = Math.max(...recentHighs);
  const lowestLow = Math.min(...recentLows);
  
  const k = ((currentClose - lowestLow) / (highestHigh - lowestLow)) * 100;
  
  return {
    k: k,
    d: k * 0.9 // Simplified D line
  };
}

// Volume Analysis
function analyzeVolume(volumes) {
  const avgVolume = calculateSMA(volumes, 20);
  const currentVolume = volumes[volumes.length - 1];
  
  return {
    current: currentVolume,
    average: avgVolume,
    ratio: currentVolume / avgVolume,
    trend: currentVolume > avgVolume ? 'increasing' : 'decreasing'
  };
}

// PATTERN DETECTION
function detectPatterns(prices) {
  const patterns = [];
  const len = prices.length;
  
  if (len < 5) return ['Insufficient data'];
  
  // Trend detection
  const recentTrend = prices[len - 1] - prices[len - 5];
  if (recentTrend > prices[len - 5] * 0.02) patterns.push('Uptrend');
  else if (recentTrend < -prices[len - 5] * 0.02) patterns.push('Downtrend');
  else patterns.push('Sideways');
  
  // Double top/bottom (simplified)
  const highs = [prices[len - 10], prices[len - 5]];
  if (Math.abs(highs[0] - highs[1]) / highs[0] < 0.01) {
    patterns.push('Potential Double Top');
  }
  
  // Head and shoulders (very simplified)
  if (prices[len - 5] > prices[len - 10] && prices[len - 5] > prices[len - 1]) {
    patterns.push('Potential Head & Shoulders');
  }
  
  return patterns;
}

// SUPPORT & RESISTANCE
function calculateSupportResistance(prices, highs, lows) {
  const currentPrice = prices[prices.length - 1];
  
  // Find recent swing highs and lows
  const resistanceLevels = [];
  const supportLevels = [];
  
  for (let i = prices.length - 50; i < prices.length - 2; i++) {
    if (highs[i] > highs[i - 1] && highs[i] > highs[i + 1]) {
      resistanceLevels.push(highs[i]);
    }
    if (lows[i] < lows[i - 1] && lows[i] < lows[i + 1]) {
      supportLevels.push(lows[i]);
    }
  }
  
  // Get closest levels
  const resistance = resistanceLevels
    .filter(r => r > currentPrice)
    .sort((a, b) => a - b)
    .slice(0, 3);
    
  const support = supportLevels
    .filter(s => s < currentPrice)
    .sort((a, b) => b - a)
    .slice(0, 3);
  
  return {
    support: support.length ? support : [currentPrice * 0.98, currentPrice * 0.95, currentPrice * 0.92],
    resistance: resistance.length ? resistance : [currentPrice * 1.02, currentPrice * 1.05, currentPrice * 1.08]
  };
}

// CRYPTO SENTIMENT (using alternative free API)
async function fetchCryptoSentiment(symbol) {
  try {
    // Alternative.me Crypto Fear & Greed Index
    const res = await fetch('https://api.alternative.me/fng/');
    const data = await res.json();
    
    const fearGreedValue = parseInt(data.data[0].value);
    
    return {
      fearGreed: fearGreedValue,
      classification: data.data[0].value_classification,
      social: fearGreedValue / 100,
      overall: fearGreedValue > 50 ? 'bullish' : 'bearish'
    };
  } catch {
    return {
      fearGreed: 50,
      classification: 'Neutral',
      social: 0.5,
      overall: 'neutral'
    };
  }
}

// HELPER FUNCTIONS
function convertTimeframe(tf) {
  const map = {
    '1M': '1m',
    '5M': '5m',
    '15M': '15m',
    '1H': '1h',
    '4H': '4h',
    '1D': '1d',
    '1W': '1w'
  };
  return map[tf] || '1h';
}

function convertTimeframeAlpha(tf) {
  const map = {
    '1M': '1min',
    '5M': '5min',
    '15M': '15min',
    '1H': '60min',
    '4H': '60min',
    '1D': 'daily',
    '1W': 'weekly'
  };
  return map[tf] || '60min';
}

// DEMO DATA FALLBACKS
function getDemoForexData(symbol) {
  return {
    symbol: symbol,
    source: 'Demo Data',
    price: 1.0850,
    note: 'Using demo data. Add Alpha Vantage API key for real data.'
  };
}

function getDemoCommodityData(symbol) {
  return {
    symbol: symbol,
    source: 'Demo Data',
    price: 2045.30,
    note: 'Using demo data. Add API key for real data.'
  };
}

function getDemoStockData(symbol) {
  return {
    symbol: symbol,
    source: 'Demo Data',
    price: 178.50,
    note: 'Using demo data. Add API key for real data.'
  };
}

async function fetchCryptoDataCoinGecko(symbol) {
  // CoinGecko fallback
  const coinId = symbol.includes('BTC') ? 'bitcoin' : 'ethereum';
  const res = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true`);
  const data = await res.json();
  
  return {
    symbol: symbol,
    source: 'CoinGecko',
    price: data[coinId].usd,
    changePercent: data[coinId].usd_24h_change,
    volume: data[coinId].usd_24h_vol
  };
}

function processAlphaVantageData(data, symbol) {
  // Generic processor for Alpha Vantage responses
  // Implementation depends on specific endpoint used
  return {
    symbol: symbol,
    source: 'Alpha Vantage',
    price: 0,
    note: 'Processing Alpha Vantage data'
  };
}
